
if (!classificaoes.contains(c)){
    thrown new IllegalArgumentException();
}
this.classificacao = c;

Não precisa de throwns porque ela é verificada

class emailControl extends email{
    private boolean lido;

    public emailControl(String r, String d, String a, String c){
        super(r, d, a, c);
        this.lido = false;
    }
}

public void setLido(booelan b){
    lida = b;
}

public booelan getLido(){
    return lido;
}

Assumindo que  email tem toString:
@Override
public String toString(){
    return super().toString + ", " + getLido();
}

3-a) remove todos os emails da lista iguais a classificação
  b) Não tem como saber qual o tipo de lista: List<Email>. Se entrar um linked list 
     ele procura na lista inteira até achar duas vezes sendo O(n^2). Se for array list 
     ele é O(1) mas tem o problema da alocação de memória. O remove também procurá 
     tudo novamente, usar um iterador para usar um get só e o remove. Jeito correto:

  c) Iterador<Email> it = emails.iterador();
     while(it.hasNext()){
        if(it.next().get().classificacao().equals(classificacao)){
            it.remove();
        }
     }

4- List<Email> soUrgentesParaGerencia(List<Email> emails){
    return emails.stream()
                        .filter(e-> e.getClassificacao.equals("urgente")
                        && e.getDestinatario.equals("gerencia"))
                        .toList();
}

5- void marcaSpam(List<Email> emails){
    emails.stream()
                .filter(e->e.getRemetente().equals("soofertas"))
                .foreach(e-> e.setClassificacao("Spam"));
}

6- long contaLidos(List<EmailControl> emails){
    return emails.stream()
                        .filter(e->e.getLido())
                        .count();
}

7- List<String> remetentesSpam(List<Email> emails){
    return emails.stream()
                        .filter(e->e.getClassificacao().equals.("Spam"))
                        .map(e->e.getRemetente())
                        .toList();
}

8- Supondo que tem idade do destinatário:
    Double idadeMedia(List<Email> emails){
        return emails.stream()
                            .filter(e->e.getClassificacao().equals("urgente"))
                            .average()
                            .getAsDouble();
    }

9- Email getEmail(String destinatario){
        return emails.stream()
                            .filter(e->e.getDestinatario.equals(destinatario))
                            .findFirst()
                            .orElse(null);
    }